{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nconst Mover_1 = require(\"./Mover\");\n\nconst Enums_1 = require(\"../../Enums\");\n\nclass Updater {\n  constructor(container, particle) {\n    this.container = container;\n    this.particle = particle;\n    this.mover = new Mover_1.Mover(container, particle);\n  }\n\n  static checkBounds(coordinate, radius, size, velocity, outside) {\n    if (coordinate + radius > size && velocity > 0 || coordinate - radius < 0 && velocity < 0) {\n      outside();\n    }\n  }\n\n  update(delta) {\n    this.mover.move(delta);\n    this.updateOpacity(delta);\n    this.updateSize(delta);\n    this.updateAngle(delta);\n    this.updateColor(delta);\n    this.fixOutOfCanvasPosition();\n    this.updateOutMode(delta);\n  }\n\n  updateOpacity(delta) {\n    const options = this.container.options;\n    const particle = this.particle;\n    const deltaFactor = options.fpsLimit > 0 ? 60 * delta / 1000 : 3.6;\n\n    if (particle.particlesOptions.opacity.animation.enable) {\n      switch (particle.opacity.status) {\n        case Enums_1.OpacityAnimationStatus.increasing:\n          if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n          } else {\n            particle.opacity.value += (particle.opacity.velocity || 0) * deltaFactor;\n          }\n\n          break;\n\n        case Enums_1.OpacityAnimationStatus.decreasing:\n          if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n          } else {\n            particle.opacity.value -= (particle.opacity.velocity || 0) * deltaFactor;\n          }\n\n          break;\n      }\n\n      if (particle.opacity.value < 0) {\n        particle.opacity.value = 0;\n      }\n    }\n  }\n\n  updateSize(delta) {\n    var _a;\n\n    const container = this.container;\n    const options = container.options;\n    const particle = this.particle;\n    const deltaFactor = options.fpsLimit > 0 ? 60 * delta / 1000 : 3.6;\n    const sizeOpt = particle.particlesOptions.size;\n    const sizeAnim = sizeOpt.animation;\n\n    if (sizeAnim.enable) {\n      switch (particle.size.status) {\n        case Enums_1.SizeAnimationStatus.increasing:\n          if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n            particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n          } else {\n            particle.size.value += (particle.size.velocity || 0) * deltaFactor;\n          }\n\n          break;\n\n        case Enums_1.SizeAnimationStatus.decreasing:\n          if (particle.size.value <= sizeAnim.minimumValue) {\n            particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n          } else {\n            particle.size.value -= (particle.size.velocity || 0) * deltaFactor;\n          }\n\n      }\n\n      switch (sizeAnim.destroy) {\n        case Enums_1.DestroyType.max:\n          if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n\n        case Enums_1.DestroyType.min:\n          if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n      }\n\n      if (particle.size.value < 0 && !particle.destroyed) {\n        particle.size.value = 0;\n      }\n    }\n  }\n\n  updateAngle(delta) {\n    const options = this.container.options;\n    const particle = this.particle;\n    const deltaFactor = options.fpsLimit > 0 ? 60 * delta / 1000 : 3.6;\n\n    if (particle.particlesOptions.rotate.animation.enable) {\n      switch (particle.rotateDirection) {\n        case Enums_1.RotateDirection.clockwise:\n          particle.angle += particle.particlesOptions.rotate.animation.speed * Math.PI / 18 * deltaFactor;\n\n          if (particle.angle > 360) {\n            particle.angle -= 360;\n          }\n\n          break;\n\n        case Enums_1.RotateDirection.counterClockwise:\n        default:\n          particle.angle -= particle.particlesOptions.rotate.animation.speed * Math.PI / 18 * deltaFactor;\n\n          if (particle.angle < 0) {\n            particle.angle += 360;\n          }\n\n          break;\n      }\n    }\n  }\n\n  updateColor(delta) {\n    const options = this.container.options;\n    const particle = this.particle;\n\n    if (particle.color === undefined) {\n      return;\n    }\n\n    const deltaFactor = options.fpsLimit > 0 ? 60 * delta / 1000 : 3.6;\n\n    if (particle.particlesOptions.color.animation.enable) {\n      particle.color.h += (particle.colorVelocity || 0) * deltaFactor;\n\n      if (particle.color.h > 360) {\n        particle.color.h -= 360;\n      }\n    }\n  }\n\n  fixOutOfCanvasPosition() {\n    const container = this.container;\n    const particle = this.particle;\n    const outMode = particle.particlesOptions.move.outMode;\n    const wrap = particle.particlesOptions.move.warp;\n    const canvasSize = container.canvas.size;\n    let newPos;\n\n    if (outMode === Enums_1.OutMode.bounce) {\n      newPos = {\n        bottom: canvasSize.height,\n        left: particle.size.value,\n        right: canvasSize.width,\n        top: particle.size.value\n      };\n    } else if (outMode === Enums_1.OutMode.bounceHorizontal) {\n      newPos = {\n        bottom: canvasSize.height + particle.size.value - particle.offset.y,\n        left: particle.size.value,\n        right: canvasSize.width,\n        top: -particle.size.value - particle.offset.y\n      };\n    } else if (outMode === Enums_1.OutMode.bounceVertical) {\n      newPos = {\n        bottom: canvasSize.height,\n        left: -particle.size.value - particle.offset.x,\n        right: canvasSize.width + particle.size.value + particle.offset.x,\n        top: particle.size.value\n      };\n    } else {\n      newPos = {\n        bottom: canvasSize.height + particle.size.value - particle.offset.y,\n        left: -particle.size.value - particle.offset.x,\n        right: canvasSize.width + particle.size.value + particle.offset.x,\n        top: -particle.size.value - particle.offset.y\n      };\n    }\n\n    if (outMode === Enums_1.OutMode.destroy) {\n      const sizeValue = particle.size.value;\n\n      if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, sizeValue)) {\n        container.particles.remove(particle);\n      }\n    } else {\n      const sizeValue = particle.size.value;\n      const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n      if (nextBounds.left > canvasSize.width - particle.offset.x) {\n        particle.position.x = newPos.left;\n\n        if (!wrap) {\n          particle.position.y = Math.random() * canvasSize.height;\n        }\n      } else if (nextBounds.right < -particle.offset.x) {\n        particle.position.x = newPos.right;\n\n        if (!wrap) {\n          particle.position.y = Math.random() * canvasSize.height;\n        }\n      }\n\n      if (nextBounds.top > canvasSize.height - particle.offset.y) {\n        if (!wrap) {\n          particle.position.x = Math.random() * canvasSize.width;\n        }\n\n        particle.position.y = newPos.top;\n      } else if (nextBounds.bottom < -particle.offset.y) {\n        if (!wrap) {\n          particle.position.x = Math.random() * canvasSize.width;\n        }\n\n        particle.position.y = newPos.bottom;\n      }\n    }\n  }\n\n  updateOutMode(delta) {\n    switch (this.particle.particlesOptions.move.outMode) {\n      case Enums_1.OutMode.bounce:\n      case Enums_1.OutMode.bounceVertical:\n      case Enums_1.OutMode.bounceHorizontal:\n        this.updateBounce(delta);\n        break;\n    }\n  }\n\n  updateBounce(delta) {\n    const container = this.container;\n    const particle = this.particle;\n    let handled = false;\n\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleBounce !== undefined) {\n        handled = plugin.particleBounce(particle, delta);\n      }\n\n      if (handled) {\n        break;\n      }\n    }\n\n    if (!handled) {\n      const outMode = particle.particlesOptions.move.outMode;\n      const pos = particle.getPosition();\n\n      if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n        const size = particle.size.value;\n        const velocity = particle.velocity.horizontal;\n        Updater.checkBounds(pos.x, size, container.canvas.size.width, velocity, () => {\n          particle.velocity.horizontal *= -1;\n        });\n      }\n\n      if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n        const size = particle.size.value;\n        const velocity = particle.velocity.vertical;\n        Updater.checkBounds(pos.y, size, container.canvas.size.height, velocity, () => {\n          particle.velocity.vertical *= -1;\n        });\n      }\n    }\n  }\n\n}\n\nexports.Updater = Updater;","map":{"version":3,"sources":["/Users/danwilloughby/Desktop/ZTM/NST/nst-art-frontend/node_modules/tsparticles/dist/Core/Particle/Updater.js"],"names":["Object","defineProperty","exports","value","Updater","Utils_1","require","Mover_1","Enums_1","constructor","container","particle","mover","Mover","checkBounds","coordinate","radius","size","velocity","outside","update","delta","move","updateOpacity","updateSize","updateAngle","updateColor","fixOutOfCanvasPosition","updateOutMode","options","deltaFactor","fpsLimit","particlesOptions","opacity","animation","enable","status","OpacityAnimationStatus","increasing","decreasing","minimumValue","_a","sizeOpt","sizeAnim","SizeAnimationStatus","sizeValue","retina","destroy","DestroyType","max","pixelRatio","min","destroyed","rotate","rotateDirection","RotateDirection","clockwise","angle","speed","Math","PI","counterClockwise","color","undefined","h","colorVelocity","outMode","wrap","warp","canvasSize","canvas","newPos","OutMode","bounce","bottom","height","left","right","width","top","bounceHorizontal","offset","y","bounceVertical","x","Utils","isPointInside","position","particles","remove","nextBounds","calculateBounds","random","updateBounce","handled","plugin","plugins","particleBounce","pos","getPosition","horizontal","vertical"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Updater = void 0;\nconst Utils_1 = require(\"../../Utils\");\nconst Mover_1 = require(\"./Mover\");\nconst Enums_1 = require(\"../../Enums\");\nclass Updater {\n    constructor(container, particle) {\n        this.container = container;\n        this.particle = particle;\n        this.mover = new Mover_1.Mover(container, particle);\n    }\n    static checkBounds(coordinate, radius, size, velocity, outside) {\n        if ((coordinate + radius > size && velocity > 0) || (coordinate - radius < 0 && velocity < 0)) {\n            outside();\n        }\n    }\n    update(delta) {\n        this.mover.move(delta);\n        this.updateOpacity(delta);\n        this.updateSize(delta);\n        this.updateAngle(delta);\n        this.updateColor(delta);\n        this.fixOutOfCanvasPosition();\n        this.updateOutMode(delta);\n    }\n    updateOpacity(delta) {\n        const options = this.container.options;\n        const particle = this.particle;\n        const deltaFactor = options.fpsLimit > 0 ? (60 * delta) / 1000 : 3.6;\n        if (particle.particlesOptions.opacity.animation.enable) {\n            switch (particle.opacity.status) {\n                case Enums_1.OpacityAnimationStatus.increasing:\n                    if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.opacity.value += (particle.opacity.velocity || 0) * deltaFactor;\n                    }\n                    break;\n                case Enums_1.OpacityAnimationStatus.decreasing:\n                    if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.opacity.value -= (particle.opacity.velocity || 0) * deltaFactor;\n                    }\n                    break;\n            }\n            if (particle.opacity.value < 0) {\n                particle.opacity.value = 0;\n            }\n        }\n    }\n    updateSize(delta) {\n        var _a;\n        const container = this.container;\n        const options = container.options;\n        const particle = this.particle;\n        const deltaFactor = options.fpsLimit > 0 ? (60 * delta) / 1000 : 3.6;\n        const sizeOpt = particle.particlesOptions.size;\n        const sizeAnim = sizeOpt.animation;\n        if (sizeAnim.enable) {\n            switch (particle.size.status) {\n                case Enums_1.SizeAnimationStatus.increasing:\n                    if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.size.value += (particle.size.velocity || 0) * deltaFactor;\n                    }\n                    break;\n                case Enums_1.SizeAnimationStatus.decreasing:\n                    if (particle.size.value <= sizeAnim.minimumValue) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.size.value -= (particle.size.velocity || 0) * deltaFactor;\n                    }\n            }\n            switch (sizeAnim.destroy) {\n                case Enums_1.DestroyType.max:\n                    if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n                case Enums_1.DestroyType.min:\n                    if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n            }\n            if (particle.size.value < 0 && !particle.destroyed) {\n                particle.size.value = 0;\n            }\n        }\n    }\n    updateAngle(delta) {\n        const options = this.container.options;\n        const particle = this.particle;\n        const deltaFactor = options.fpsLimit > 0 ? (60 * delta) / 1000 : 3.6;\n        if (particle.particlesOptions.rotate.animation.enable) {\n            switch (particle.rotateDirection) {\n                case Enums_1.RotateDirection.clockwise:\n                    particle.angle += ((particle.particlesOptions.rotate.animation.speed * Math.PI) / 18) * deltaFactor;\n                    if (particle.angle > 360) {\n                        particle.angle -= 360;\n                    }\n                    break;\n                case Enums_1.RotateDirection.counterClockwise:\n                default:\n                    particle.angle -= ((particle.particlesOptions.rotate.animation.speed * Math.PI) / 18) * deltaFactor;\n                    if (particle.angle < 0) {\n                        particle.angle += 360;\n                    }\n                    break;\n            }\n        }\n    }\n    updateColor(delta) {\n        const options = this.container.options;\n        const particle = this.particle;\n        if (particle.color === undefined) {\n            return;\n        }\n        const deltaFactor = options.fpsLimit > 0 ? (60 * delta) / 1000 : 3.6;\n        if (particle.particlesOptions.color.animation.enable) {\n            particle.color.h += (particle.colorVelocity || 0) * deltaFactor;\n            if (particle.color.h > 360) {\n                particle.color.h -= 360;\n            }\n        }\n    }\n    fixOutOfCanvasPosition() {\n        const container = this.container;\n        const particle = this.particle;\n        const outMode = particle.particlesOptions.move.outMode;\n        const wrap = particle.particlesOptions.move.warp;\n        const canvasSize = container.canvas.size;\n        let newPos;\n        if (outMode === Enums_1.OutMode.bounce) {\n            newPos = {\n                bottom: canvasSize.height,\n                left: particle.size.value,\n                right: canvasSize.width,\n                top: particle.size.value,\n            };\n        }\n        else if (outMode === Enums_1.OutMode.bounceHorizontal) {\n            newPos = {\n                bottom: canvasSize.height + particle.size.value - particle.offset.y,\n                left: particle.size.value,\n                right: canvasSize.width,\n                top: -particle.size.value - particle.offset.y,\n            };\n        }\n        else if (outMode === Enums_1.OutMode.bounceVertical) {\n            newPos = {\n                bottom: canvasSize.height,\n                left: -particle.size.value - particle.offset.x,\n                right: canvasSize.width + particle.size.value + particle.offset.x,\n                top: particle.size.value,\n            };\n        }\n        else {\n            newPos = {\n                bottom: canvasSize.height + particle.size.value - particle.offset.y,\n                left: -particle.size.value - particle.offset.x,\n                right: canvasSize.width + particle.size.value + particle.offset.x,\n                top: -particle.size.value - particle.offset.y,\n            };\n        }\n        if (outMode === Enums_1.OutMode.destroy) {\n            const sizeValue = particle.size.value;\n            if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, sizeValue)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            const sizeValue = particle.size.value;\n            const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n            if (nextBounds.left > canvasSize.width - particle.offset.x) {\n                particle.position.x = newPos.left;\n                if (!wrap) {\n                    particle.position.y = Math.random() * canvasSize.height;\n                }\n            }\n            else if (nextBounds.right < -particle.offset.x) {\n                particle.position.x = newPos.right;\n                if (!wrap) {\n                    particle.position.y = Math.random() * canvasSize.height;\n                }\n            }\n            if (nextBounds.top > canvasSize.height - particle.offset.y) {\n                if (!wrap) {\n                    particle.position.x = Math.random() * canvasSize.width;\n                }\n                particle.position.y = newPos.top;\n            }\n            else if (nextBounds.bottom < -particle.offset.y) {\n                if (!wrap) {\n                    particle.position.x = Math.random() * canvasSize.width;\n                }\n                particle.position.y = newPos.bottom;\n            }\n        }\n    }\n    updateOutMode(delta) {\n        switch (this.particle.particlesOptions.move.outMode) {\n            case Enums_1.OutMode.bounce:\n            case Enums_1.OutMode.bounceVertical:\n            case Enums_1.OutMode.bounceHorizontal:\n                this.updateBounce(delta);\n                break;\n        }\n    }\n    updateBounce(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (!handled) {\n            const outMode = particle.particlesOptions.move.outMode;\n            const pos = particle.getPosition();\n            if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n                const size = particle.size.value;\n                const velocity = particle.velocity.horizontal;\n                Updater.checkBounds(pos.x, size, container.canvas.size.width, velocity, () => {\n                    particle.velocity.horizontal *= -1;\n                });\n            }\n            if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n                const size = particle.size.value;\n                const velocity = particle.velocity.vertical;\n                Updater.checkBounds(pos.y, size, container.canvas.size.height, velocity, () => {\n                    particle.velocity.vertical *= -1;\n                });\n            }\n        }\n    }\n}\nexports.Updater = Updater;\n"]},"metadata":{},"sourceType":"script"}